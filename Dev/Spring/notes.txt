Java is widely used as a server-side programming language in enterprise applications, web development, and microservices.

Servelet : Java Servelets are java classes that runs on a server and handles client requests and responses.They basically handles behind the scene logics.

Java Servelet supports all kind of protocols but primiraly it is most often used with Http protocols (a set of rules for web communication such as requesting and delivering pages).

JSP : Java Server Pages used to build dynamic web pages by embedding the Java code to HTML.
A  Jsp is slower than servelet because first step in JSP life cycle is to convert the JSP code to servelet code and then it compiles. 
JSP only accepts HTTP/HTTPs requests.


--------------------------------------------
Java is widely used as a server-side programming language in enterprise applications, web development, and microservices.

Servelet : Java Servelets are java classes that runs on a server and handles client requests and responses.They basically handles behind the scene logics.

Java Servelet supports all kind of protocols but primiraly it is most often used with Http protocols (a set of rules for web communication such as requesting and delivering pages).

JSP : Java Server Pages used to build dynamic web pages by embedding the Java code to HTML.
A  Jsp is slower than servelet because first step in JSP life cycle is to convert the JSP code to servelet code and then it compiles. 

Initially, enterprise Java used Servlets and JSPs, which mixed business logic with presentation. Then EJB came to provide transactions, security, and distributed capabilities but was heavyweight and complex. Spring was introduced in 2002 as a lightweight, POJO-based alternative to simplify enterprise development.


MVC -> Model View Controller 
Model ->  Model represents the data and business logic. It is responsible for defining how the data is stored, retrieved and manipulated.
In spring Model basically includes the entity classes, DAO or Repository layer and business logic or services.

View -> View is responsible for presenting the data to user screen. It basically displays the info given by controller usually a web page or UI component. It does not contain any business logic. It handles the presentation part.

Controller -> Controller basically is responsible for handling user requests, processing input and coordinating between the model and view. It acts as a bridge between view and model. A client sends request and controller sends that request to service / model and then it sends response to user.


Application Properties: This is a configuration file where you define your project's settings, such as server port numbers, database connections, or other application-specific properties.

POM: Project Object Model This file have all the external dependencies, plugins, build settings. It also contains metadata of project like project artifact id , group and version.


A model class in java is a blueprint of all essential details of a particular product.


@Controller is annotation which is used to mark a class as a Controller. It tells spring that this will handle web requests.
@RequestMapping is an annotation used in spring to map HTTP requests to some handler methods or classes.
@ResponseBody is a spring annotation used on a controller method which indicates that what should be written directly to HTTP response body.
@PathVariable is a spring annotation used to extract the dynamic value from URL path and use them in our methods as a parameter.


If creating a view with jsp we need to add some dependencies to pom.xml which includes tomcat-embed-jasper
tomcat is a server where our app runs and jasper is the compiler that is used to convert jsp file to java servlets. so that they can be run on browser by converting servlets to byte codes.

Thymeleaf -> is a java template engine used to create dynamic web pages in spring.

Hibernate : is a popular Java framework used for Object relational mapping (ORM).It helps by mapping classes to Tables and manages the database operations without writing complex database queries.
It maps the classes name with table and object with the rows.

In hibernate we need to manage sessions. A session is the connection to database which manages the persistence of entities.Then session.begintransaction() session.persist(obj)  tx.commit() session.close()


JPA : is a java specification that makes it easy to work with relational databases. It defines some rules that how objects are mapped to database tables and also manages their persistence. It provides a set of annotations and interfaces to perform crud operations in easier manner but it requires implementation like hibernate to actually interact to database.


Basic Interfaces 
EntityTransaction -> mANAGES transactions in JPA (begin, commit,rollback)
EntityManagerFactory -> interface which create instances of EMF
EntityManager - > interface to interact with persistent context.
Query / TypedQuery -> JPQL, Native Queries.

Annotations
@Entity
@Table -> optional used when we need a specified tablename
@Id -> mars field as a primar key of entity.
@GeneratedValue -> Specifies key gen strategy.
@Column -> optional marks a specific column name
@Transient -> to makea field transient


ORM (Object-Relational Mapping) is a technique that maps Java objects to database tables, allowing developers to perform database operations using objects instead of SQL. It simplifies CRUD operations, manages relationships, and keeps the object model in sync with the database.


Spring boot is a Java Framework which is built on the top of Spring Framework and it simplifies the development of standalone ,production grade apps by providing auto configuration and reducing boilerplate code.

It provides started dependencies , auto config and embedded servers.

Bean -> A bean is an object which is created and managed by spring ioc or spring application context. Its not created by new keyword.

@Component -> an annotation which marks a class as a bean.

REST â†’ REST stands for Representational State Transfer.
REST is an architectural style that defines a set of rules for communication between applications over HTTP in a standardized way.

HTTP is a stateless protocol, meaning each request is independent and does not rely on previous requests. Every request must contain all the necessary information (like resource identifiers or authentication data), which makes REST services scalable and easier to maintain.

Restful service take request from client and gets response from server.

@RestController -> is a special annotation in spring that marks a class as RestController.
It is used to create RESTfull services that returns data directly to client in JSON format.It combines the functionality of @Controller and @ResponseBody


Spring Security
Spring security is a framework used for authentication and authorization in spring applications.
It protects the app from common security threats.


Authentication : verify who the user is
Authorization : determine what user is allowed to do 
After adding security dependency into Spring Boot, when we run our application, then it automatically redirects to login page as per the default implementation of Security Config, which provides its default login form and in build logs we can see password also. Also, if we provide password and username in application.properties, then we can directly login with those credentials.

How to apply custom Spring Security
-> To apply Spring Security with custom setting, we need to follow some steps... Firstly, we need to create a SecurityConfig class under a config package. In this class, we need to implement filter chains by defining a method securityFilterChain whose return type is an instance of SecurityFilterChain, which is an interface under security.web default package. In its arguments, we need to provide HttpSecurity object.

Then we need to define the function which goes like http.authorizeHttpRequests() then lambda function in it, which will match requests using requestMatchers() in which we need to provide allowed URLs, then .permitAll. Then we need to give .anyRequest().authenticated, which means other than matching endpoints all need a login to continue.

Then we can use http.formLogin() and in the args we can use a lambda for form like form.loginPage(), form.defaultSuccessUrl(), .permitAll(). Then http.logout() and in args we need to give logout.permitAll().

This filter chain defines a set of some security rules that need to be followed during authentication. Then our authentication manager does not know user details of a person stored. So it calls UserDetailsService, which is an interface and contains a method loadUserByUsername(). It is by default implemented by InMemoryUserDetailsManager class, which implements that method and creates user with the help of method createUser.

This all happens in memory by default. Also, this class creates new password in memory every time app restarts.

We can use it in two ways:
-> In-memory user
-> By connecting external database


For inmemory user we can do it in multiple ways we can either use can create a function which returns UserDetailsService instance with the help of InmemoryUserDetailsManager constructor which takes object of UserDetails as a parameter.

or we can create a class UserDetails which must implements UserDetailsService interface in which we can take a HashMap to store users and that class must override the loaduser by username method.  or we can also take requests and map them with inmemoryusermanager

For using a database spring security we can create a custom UserService class in which we need to implement the userdetailsservie  interface method loadusrbyUsername. 

Role Based Security
@PreAuthorise("hasRole('User')") -> enables only users to access that endpoint
@PostAuthorise()

JWT -> JSON Web Token
Jwt is an openindustry standard to securely transmit information between two parties as a JSON object.

Its a long string divided into 3 parts:

Header : Info about the algo used and token type
Payload : Data transferred usually the _id
Signature : Ensures data is secure

Normal AUthentication in spring boot does not have advance featues.
It does not have expiration time. If we have authorized someone to our system and we wanna take away auth then there is no way by default. NORMAL auth can be decoded easily.



Filter Chain is a design pattern by which we can create different filters.

Requests comes from Tomcat servers and then it went through filter chain . filter chain have different filters like corsfilter , char encoding filter which checks requests fpffernt works
 

































